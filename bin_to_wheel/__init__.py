"""bin-to-wheel: Package pre-built binaries into Python wheels."""

import argparse
import base64
import csv
import hashlib
import io
import os
import platform
import re
import stat
import sys
import zipfile
from pathlib import Path

__version__ = "0.1.0"

# ---------------------------------------------------------------------------
# Epic 1: Name normalization
# ---------------------------------------------------------------------------

def normalize_package_name(name: str) -> str:
    """Normalize a package name per PEP 503: lowercase, hyphens/dots → underscores."""
    return re.sub(r"[-.]", "_", name).lower()


def normalize_version(version: str) -> str:
    """Normalize a version string per PEP 440.

    Strips leading zeros from each numeric segment:
      "26.02.16" → "26.2.16"
      "1.0.0" → "1.0.0" (unchanged)
    """
    parts = version.split(".")
    normalized = []
    for part in parts:
        if part.isdigit():
            normalized.append(str(int(part)))
        else:
            normalized.append(part)
    return ".".join(normalized)


# ---------------------------------------------------------------------------
# Epic 2: RECORD hash computation
# ---------------------------------------------------------------------------

def compute_file_hash(content: bytes) -> str:
    """SHA-256 hash of content, URL-safe base64 encoded with padding stripped."""
    digest = hashlib.sha256(content).digest()
    return base64.urlsafe_b64encode(digest).rstrip(b"=").decode("ascii")


# ---------------------------------------------------------------------------
# Epic 5: Platform tag handling
# ---------------------------------------------------------------------------

PLATFORM_TAGS: dict[str, str] = {
    "linux-x86_64": "manylinux_2_17_x86_64",
    "linux-arm64": "manylinux_2_17_aarch64",
    "macos-arm64": "macosx_11_0_arm64",
    "macos-x86_64": "macosx_10_15_x86_64",
    "windows-x64": "win_amd64",
}

# All known raw tags (values from PLATFORM_TAGS)
_KNOWN_RAW_TAGS = set(PLATFORM_TAGS.values())


def resolve_platform_tag(tag: str) -> str:
    """Resolve a friendly name or raw PEP 427 platform tag."""
    if tag in PLATFORM_TAGS:
        return PLATFORM_TAGS[tag]
    if tag in _KNOWN_RAW_TAGS or _looks_like_raw_tag(tag):
        return tag
    raise ValueError(
        f"Unknown platform: {tag!r}. "
        f"Use one of: {', '.join(sorted(PLATFORM_TAGS.keys()))} "
        f"or a raw PEP 427 tag."
    )


def _looks_like_raw_tag(tag: str) -> bool:
    """Heuristic: raw tags contain underscores and look like manylinux/macosx/win."""
    return bool(re.match(r"^(manylinux|musllinux|macosx|win|linux)", tag))


def detect_current_platform() -> str:
    """Detect the current platform and return a wheel platform tag."""
    system = platform.system().lower()
    machine = platform.machine().lower()

    if system == "linux":
        if machine == "x86_64":
            return "manylinux_2_17_x86_64"
        if machine == "aarch64":
            return "manylinux_2_17_aarch64"
        return f"linux_{machine}"
    elif system == "darwin":
        if machine == "arm64":
            return "macosx_11_0_arm64"
        return "macosx_10_15_x86_64"
    elif system == "windows":
        if machine in ("amd64", "x86_64"):
            return "win_amd64"
        return f"win_{machine}"
    else:
        return f"{system}_{machine}"


# ---------------------------------------------------------------------------
# Epic 3: Generated file content
# ---------------------------------------------------------------------------

def generate_init_py(version: str, binary_name: str | list[str]) -> str:
    """Generate __init__.py for the installed wheel package.

    binary_name can be a single name or a list of names for multi-binary wheels.
    """
    if isinstance(binary_name, str):
        binary_names = [binary_name]
    else:
        binary_names = list(binary_name)

    names_repr = repr(binary_names)

    # Build per-binary main functions
    func_lines = []
    for name in binary_names:
        normalized = re.sub(r"[^a-zA-Z0-9]", "_", name).rstrip("_")
        func_lines.append(f"""
def main_{normalized}():
    \"\"\"Run the bundled '{name}' binary.\"\"\"
    _run_binary({name!r})
""")

    extra_funcs = "\n".join(func_lines)

    return f'''\
"""Auto-generated by bin-to-wheel."""

import os
import stat
import subprocess
import sys
from pathlib import Path

__version__ = "{version}"

BINARY_NAMES = {names_repr}


def get_binary_path(name: str | None = None) -> Path:
    """Return the path to a bundled binary (default: first binary)."""
    if name is None:
        name = BINARY_NAMES[0]
    return Path(__file__).parent / "bin" / name


def _run_binary(name: str) -> None:
    """Run a bundled binary by name, passing through all arguments."""
    binary = get_binary_path(name)

    # Fix execute permission if stripped by installer
    if not os.access(binary, os.X_OK):
        binary.chmod(binary.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    if sys.platform != "win32":
        os.execvp(str(binary), [str(binary)] + sys.argv[1:])
    else:
        raise SystemExit(subprocess.call([str(binary)] + sys.argv[1:]))

{extra_funcs}
def main():
    """Run the first bundled binary (default entry point)."""
    _run_binary(BINARY_NAMES[0])
'''


def generate_main_py() -> str:
    """Generate __main__.py for python -m support."""
    return "from . import main\n\nmain()\n"


def generate_metadata(
    name: str,
    version: str,
    description: str | None = None,
    author: str | None = None,
    license_name: str | None = None,
    url: str | None = None,
    long_description: str | None = None,
) -> str:
    """Generate PEP 566 METADATA file content."""
    lines = [
        "Metadata-Version: 2.1",
        f"Name: {name}",
        f"Version: {version}",
    ]
    if description:
        lines.append(f"Summary: {description}")
    if url:
        lines.append(f"Home-page: {url}")
    if author:
        lines.append(f"Author: {author}")
    if license_name:
        lines.append(f"License: {license_name}")
    if long_description:
        lines.append("Description-Content-Type: text/markdown")
        lines.append("")
        lines.append(long_description)
    else:
        lines.append("")
    return "\n".join(lines) + "\n"


def generate_wheel_metadata(platform_tag: str) -> str:
    """Generate PEP 427 WHEEL metadata file content."""
    return (
        "Wheel-Version: 1.0\n"
        f"Generator: bin-to-wheel {__version__}\n"
        "Root-Is-Purelib: false\n"
        f"Tag: py3-none-{platform_tag}\n"
    )


def generate_entry_points(
    entry_point: str | list[tuple[str, str]],
    import_name: str,
) -> str:
    """Generate entry_points.txt content.

    entry_point can be:
      - a single string (backward compat): maps to import_name:main
      - a list of (ep_name, func_name) tuples for multi-binary wheels
    """
    lines = ["[console_scripts]"]
    if isinstance(entry_point, str):
        lines.append(f"{entry_point} = {import_name}:main")
    else:
        for ep_name, func_name in entry_point:
            lines.append(f"{ep_name} = {import_name}:{func_name}")
    return "\n".join(lines) + "\n"


def generate_record(
    files: dict[str, bytes],
    record_path: str | None = None,
) -> str:
    """Generate RECORD file content per PEP 376."""
    buf = io.StringIO()
    writer = csv.writer(buf, lineterminator="\n")
    for filepath, content in sorted(files.items()):
        h = compute_file_hash(content)
        writer.writerow([filepath, f"sha256={h}", str(len(content))])
    if record_path:
        writer.writerow([record_path, "", ""])
    return buf.getvalue()


# ---------------------------------------------------------------------------
# Epic 4: Wheel ZIP assembly
# ---------------------------------------------------------------------------

def build_wheel(
    binary_path: Path | list[Path],
    output_dir: Path,
    name: str,
    version: str,
    platform_tag: str,
    entry_point: str | list[str] | None = None,
    description: str | None = None,
    author: str | None = None,
    license_name: str | None = None,
    url: str | None = None,
    long_description: str | None = None,
) -> Path:
    """Build a wheel file from pre-built binary(ies). Returns the output path.

    binary_path: single Path or list of Paths
    entry_point: single name, or list of names (paired with binary_path list)
    """
    version = normalize_version(version)
    output_dir = Path(output_dir)

    # Normalize to lists
    if isinstance(binary_path, (str, Path)):
        binary_paths = [Path(binary_path)]
    else:
        binary_paths = [Path(p) for p in binary_path]

    if entry_point is None:
        entry_points_list: list[str] = []
    elif isinstance(entry_point, str):
        entry_points_list = [entry_point]
    else:
        entry_points_list = list(entry_point)

    if entry_points_list and len(entry_points_list) != len(binary_paths):
        raise ValueError(
            f"Got {len(entry_points_list)} entry points for "
            f"{len(binary_paths)} binaries — counts must match"
        )

    for bp in binary_paths:
        if not bp.exists():
            raise FileNotFoundError(f"Binary not found: {bp}")

    import_name = normalize_package_name(name)
    binary_names = [bp.name for bp in binary_paths]
    dist_info = f"{import_name}-{version}.dist-info"

    # Collect all files (path in zip → bytes)
    wheel_files: dict[str, bytes] = {}

    # Package files
    wheel_files[f"{import_name}/__init__.py"] = generate_init_py(version, binary_names).encode()
    wheel_files[f"{import_name}/__main__.py"] = generate_main_py().encode()

    for bp in binary_paths:
        wheel_files[f"{import_name}/bin/{bp.name}"] = bp.read_bytes()

    # Dist-info files
    wheel_files[f"{dist_info}/METADATA"] = generate_metadata(
        name=name,
        version=version,
        description=description,
        author=author,
        license_name=license_name,
        url=url,
        long_description=long_description,
    ).encode()
    wheel_files[f"{dist_info}/WHEEL"] = generate_wheel_metadata(platform_tag).encode()

    # Entry points
    if entry_points_list:
        if len(entry_points_list) == 1:
            # Single entry point — backward compatible format
            ep_arg: str | list[tuple[str, str]] = entry_points_list[0]
        else:
            # Multi-binary: build (ep_name, func_name) pairs
            ep_arg = []
            for ep_name, bname in zip(entry_points_list, binary_names):
                normalized = re.sub(r"[^a-zA-Z0-9]", "_", bname).rstrip("_")
                ep_arg.append((ep_name, f"main_{normalized}"))
        wheel_files[f"{dist_info}/entry_points.txt"] = generate_entry_points(
            ep_arg, import_name
        ).encode()

    # RECORD (must be last — references all other files)
    record_path = f"{dist_info}/RECORD"
    record_content = generate_record(wheel_files, record_path=record_path)
    wheel_files[record_path] = record_content.encode()

    # Build the ZIP
    wheel_filename = f"{import_name}-{version}-py3-none-{platform_tag}.whl"
    wheel_path = output_dir / wheel_filename

    bin_paths_in_zip = {f"{import_name}/bin/{bp.name}" for bp in binary_paths}

    with zipfile.ZipFile(wheel_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        for filepath, content in sorted(wheel_files.items()):
            info = zipfile.ZipInfo(filepath)
            if filepath in bin_paths_in_zip:
                info.external_attr = (0o100755 << 16)
            else:
                info.external_attr = (0o100644 << 16)
            zf.writestr(info, content)

    return wheel_path


# ---------------------------------------------------------------------------
# Epic 6: CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        prog="bin-to-wheel",
        description="Package pre-built binaries into a Python wheel.",
    )
    parser.add_argument("--name", required=True, help="Package name (e.g. erpl-adt)")
    parser.add_argument("--version", required=True, help="Package version")
    parser.add_argument("--binary", required=True, action="append",
                        help="Path to binary (repeatable for multi-binary wheels)")
    parser.add_argument("--output-dir", default="dist", help="Output directory (default: dist)")
    parser.add_argument("--entry-point", action="append",
                        help="Console script name (repeatable, pairs with --binary)")
    parser.add_argument("--description", help="Package description")
    parser.add_argument("--author", help="Package author")
    parser.add_argument("--license", dest="license_name", help="License identifier")
    parser.add_argument("--url", help="Project URL")
    parser.add_argument("--readme", help="Path to README file for long description")

    platform_group = parser.add_mutually_exclusive_group(required=True)
    platform_group.add_argument("--platform", help="Platform tag (friendly name or raw)")
    platform_group.add_argument("--auto-platform", action="store_true", help="Auto-detect platform")

    args = parser.parse_args()

    # Validate binaries exist
    binary_paths = [Path(b) for b in args.binary]
    for bp in binary_paths:
        if not bp.exists():
            print(f"Error: binary not found: {bp}", file=sys.stderr)
            raise SystemExit(1)

    # Validate entry point count matches binary count
    entry_points = args.entry_point  # None or list
    if entry_points and len(entry_points) != len(binary_paths):
        print(
            f"Error: got {len(entry_points)} --entry-point flags "
            f"for {len(binary_paths)} --binary flags — counts must match",
            file=sys.stderr,
        )
        raise SystemExit(1)

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    if args.auto_platform:
        platform_tag = detect_current_platform()
    else:
        try:
            platform_tag = resolve_platform_tag(args.platform)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            raise SystemExit(1)

    long_description = None
    if args.readme:
        readme_path = Path(args.readme)
        if readme_path.exists():
            long_description = readme_path.read_text()

    # Normalize for build_wheel: single binary → Path, multiple → list[Path]
    bp_arg: Path | list[Path] = binary_paths[0] if len(binary_paths) == 1 else binary_paths
    ep_arg: str | list[str] | None = None
    if entry_points:
        ep_arg = entry_points[0] if len(entry_points) == 1 else entry_points

    try:
        wheel_path = build_wheel(
            binary_path=bp_arg,
            output_dir=output_dir,
            name=args.name,
            version=args.version,
            platform_tag=platform_tag,
            entry_point=ep_arg,
            description=args.description,
            author=args.author,
            license_name=args.license_name,
            url=args.url,
            long_description=long_description,
        )
        print(wheel_path)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        raise SystemExit(1)
